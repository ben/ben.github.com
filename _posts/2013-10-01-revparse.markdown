---
layout: post-no-feature
title: "libgit2: Revparse"
date: 2013-10-01 15:34
comments: true
published: false
categories: draft
---

There are lots of places where the Git command line makes your life easier by letting you abbreviate some of the inputs.
In the documents, it calls these parameters "commitish" or "treeish", which means you just have to give it a place to start looking for a commit or a tree.
Under the covers, git is passing these arguments through a command called [rev-parse](http://git-scm.com/docs/git-rev-parse), which defines a DSL for looking up objects in a git repository.
Libgit2 exposes this with a pretty simple API:

```c
  git_object *obj;
  int error = git_revparse_single(&obj, repo, "HEAD^3");
```

One thing to know about the `git_object` type in libgit2 is that it's sort of a "base class" for other types of objects.
For instance, if you **know** that the object you'll find is a commit, you can do this:

```c
  git_commit *commit;
  int error = git_revparse_single(
    (git_object**)&commit, repo, "abc123");
```

Be careful what happens if it's not, though; the memory you're using may not contain what you expect.
It's a lot safer to let libgit2 *ensure* that the thing you're getting is a commit.
There are at least three ways I can think of right now to do this.

### Check Types

One is by just checking the type of the object that comes back:

```c
  if (git_object_type(obj) != GIT_OBJ_COMMIT)
  { /* ERROR */ }
```

This adds a couple lines of code everywhere you do an object lookup, and it tends to obfuscate what you're really trying to do.

### Ensured by API
Another is to use a type-specific lookup API:

```c
  git_commit *commit;
  if (git_commit_lookup(&commit, repo,
                        git_object_id(obj)) < 0)
  { /* ERROR */ }
  git_object_free(obj);
```

This will
However, it *does* mean that you have two objects to free, instead of just one.

The one I like best is the rev-parse syntax for "dereferencing to an object of a specific type".
It looks a bit riskier, but the revparse logic will do the right thing for me:

```c
  git_commit *commit;
  if (git_revparse_single((git_object**)&commit,
                          repo, "HEAD^{commit}"))
  { /* ERROR */ }
```

All of these methods will drop into the `ERROR` block if the object that comes back isn't an actual commit.

The rev-parse API has another mode that works on ranges as well.
Check out [the header](https://github.com/libgit2/libgit2/blob/development/include/git2/revparse.h) or [the documentation](http://libgit2.github.com/libgit2/#HEAD/group/revparse) for more.
ïœ©
